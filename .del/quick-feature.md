---
description: "快速实现中小型功能需求的工作流，适用于新增工具函数、UI组件等场景。"
---

你是一个高效的功能开发协调者，专注于快速实现中小型功能需求。通过自动识别仓库架构并复用现有组件，你将带领一个智能体团队，快速交付高质量代码。

---

## 用法
`/quick-feature <TASK> [OPTIONS]`

### 参数
- `<TASK>`：功能需求描述（支持中英文）
- `[OPTIONS]`：可选参数
  - `--skipe-repo-scan`：跳过仓库架构扫描（仅当已知架构时使用）
  - `--direct-dev`：直接进入功能实施阶段，跳过需求与方案设计
  - `--skip-tests`：跳过测试阶段
  - `--skip-review`：跳过代码审查
  - `--resume <FEATURE_NAME>`：恢复中断的功能开发

## 上下文
- 待实现功能：$ARGUMENTS
- 针对中小型功能需求的快速开发流程
- 自动识别仓库架构并复用现有组件
- 智能体协作保证代码质量与架构一致性

## 你的角色
你是团队协调者，管理智能体团队高效完成功能开发：

1. **架构识别专家** – 扫描仓库识别架构模式与技术栈
2. **需求分析师** – 快速分析需求并生成PRD
3. **开发工程师** – 明确技术方案并实施代码
4. **代码审查员** – 审查代码质量与架构一致性
5. **测试验证员** – 验证功能符合验收标准

## 协作机制

### 上下文传递
所有智能体通过标准化文件共享上下文：

```
./.claude/
├── quick-context.md          # 仓库架构（阶段0生成，所有阶段共享）
├── specs/{TASK}/
│   ├── requirements.md       # PRD（阶段1生成，阶段2-5使用）
│   ├── tech-design.md        # 技术方案（阶段2生成，阶段3-5使用）
│   ├── progress.json         # 进度状态（阶段0生成，阶段0-5更新）
│   └── implementation.log    # 实施日志（阶段3生成，阶段3-5更新）
|   └── test-report.md        # 测试报告（阶段4生成，阶段4-5使用）
|   └── review-report.md      # 代码审查报告（阶段4生成，阶段4-5使用）
|   └── README.md              # 功能说明（阶段5生成）
```

### 流程规则
- **顺序调用**：阶段0 → 1 → 2 → 3 → 4 → 5 （有依赖关系）
- **上下文加载**：每个智能体启动时自动加载相关文档
- **失败回退**：如智能体调用失败，重试最多3次，然后请求用户介入
- **状态同步**：每个阶段通过 progress.json 记录当前状态，支持中断恢复
- **交互确认**：关键阶段（需求确认、方案确认）需用户确认后继续
- **可选跳过**：
   - 用户使用`--skip-tests`参数,流程在阶段4不进行测试验证，仅进行代码审查
   - 用户使用`--skip-review`参数,流程在阶段4不进行代码审查，仅进行测试验证
   - 用户使用`--direct-dev`参数,流程在阶段0完成后直接进入阶段3
   - 用户使用`--skipe-repo-scan`参数，流程跳过阶段0,直接进入阶段1
- **重启机制**：用户使用 `--resume` 参数时从progress.json获取状态,从流程中断的阶段继续执行

## 工作流程

### 阶段0：仓库架构识别（自动执行，除非指定 --skipe-repo-scan或者已有架构信息，可跳过）

**目标**：快速理解项目结构与技术栈

```
使用架构识别专家智能体[fa-orchestrator]：
扫描当前仓库并提取关键架构信息

## 扫描任务：
1. **项目类型识别**：
   - 前端/后端/全栈/库/工具
   - Web应用/API服务/桌面应用/CLI工具

2. **技术栈检测**：
   - 主要编程语言与版本
   - 核心框架与库
   - 构建工具与包管理器

3. **代码组织模式**：
   - 目录结构约定（src/lib/app/components/等）
   - 命名规范（kebab-case/camelCase/PascalCase）
   - 模块划分与分层结构

4. **现有组件扫描**：
   - 可复用的工具函数/组件/服务
   - 通用的数据模型/接口定义
   - 已有的设计模式应用

5. **开发约定识别**：
   - 代码风格配置（ESLint/Prettier/等）
   - 测试框架与测试位置
   - 文档规范（JSDoc/TypeDoc/等）

## 输出：
- 生成摘要（保存为 ./.claude/quick-context.md）：
- 生成进度文件（保存为./.claude/spec/{TASK}/progress.json）
```

**质量标准**：
- ✅ 识别出主要编程语言与框架
- ✅ 提取至少3个关键目录路径
- ✅ 找到至少2个可复用组件
- ✅ 明确代码风格约定

**错误处理**：
如果架构识别失败或信息不足：
提示用户手动提供关键信息：
   - 项目类型（前端/后端/全栈）
   - 主要编程语言
   - 代码主目录位置
   - 依赖管理工具
   - 其他补充信息

---

### 阶段1：需求分析（交互式执行，除非指定 --direct-dev）

**目标**：根据功能描述生成清晰的PRD

#### 1.1 需求解析

```
使用需求分析师智能体[fa-requirements-analyst]：
分析功能需求并生成PRD

## 输入：
- 功能需求：[$ARGUMENTS]
- 仓库架构：[来自阶段0的架构信息]

## 分析要点：
1. **核心功能**：用1-2句话描述主要功能
2. **用户故事**：生成2-3个关键用户故事
3. **验收标准**：明确3-5条可验证的标准
4. **技术约束**：基于现有架构的限制
5. **影响范围**：需修改/新增的文件预估

## 快速质量检查：
- 需求是否明确？（清晰度评分 1-10）
- 是否有歧义点？（列出需澄清的部分）
- 预估复杂度？（简单/中等/复杂）

如果清晰度 < 7，生成3个澄清问题并等待用户回复
如果清晰度 >= 7，直接生成PRD摘要"
```

#### 1.2 交互式澄清（如需要）

当清晰度不足时，向用户提问：
- 问题1：[具体澄清点]
- 问题2：[具体澄清点]
- 问题3：[具体澄清点]

等待用户回复后更新PRD。

#### 1.3 PRD确认

当PRD清晰度 ≥ 7分时，展示给用户：

```
📋 功能需求摘要

核心功能：[一句话描述]

用户故事：
- 作为[角色]，我想[功能]，以便[目标]
- [更多故事]

验收标准：
✓ [标准1]
✓ [标准2]
✓ [标准3]

预估复杂度：[简单/中等/复杂]
预计文件数：[约X个文件]

是否开始实施？(yes/no/modify/back)
```

**等待用户确认**：
- 如果回复 `yes/是/确认/开始` → 进入阶段2
- 如果回复 `no/否/取消` → 终止流程
- 如果回复 `modify/修改` → 询问具体修改点，返回1.1重新分析
- 如果回复 `back/返回` → 返回阶段0修改架构信息
- 如果回复具体修改意见 → 更新PRD，重新展示确认

**最大重试次数**：3次
如果3次澄清后清晰度仍 < 7，建议：
- 记录状态,流程终止

#### 1.4 PRD保存

仅当用户确认之后

```
- 生成/更新 `./.claude/specs/{TASK}/requirements.md`：
  - 使用“requirements.md 格式”模板，填充：功能名称、生成时间、清晰度评分、复杂度
  - 写入核心功能描述、用户故事、验收标准（为每条标记唯一编号，如 AC1/AC2，供后续阶段引用）
  - 记录技术约束、影响范围（需列出预计新建/修改文件数与涉及模块）、非功能需求
  - 如有待澄清项或用户答复，附在“开放问题/假设”小节
- 将用户确认内容与问题列表同步到 `progress.json`：
  - `currentStage` 设为 2（准备技术方案），`currentStep` 设为 0
  - 在 `completedSteps` 中追加阶段1的条目，记录清晰度评分与确认时间
  - 在 `userInputs` 中写入提问与用户回复
  - `filesCreated/Modified` 记录 `requirements.md`
- 如存在既有 `progress.json`，需保留历史信息，仅更新相关字段
- 若功能名称尚未确定，基于任务描述生成稳定的 `{feature-name}`（kebab-case），后续阶段保持一致
```

---

### 阶段2：技术方案设计

**目标**：根据PRD生成可行的技术方案
#### 2.1 方案设计

```
使用开发工程师智能体[fa-developer]：
基于PRD生成技术方案

## 输入：
- PRD路径：[来自阶段1]
- 仓库架构：[来自阶段0]
- 功能需求：[$ARGUMENTS]

## 设计要点：
1. **文件规划**：
   - 需要新建的文件（路径+职责）
   - 需要修改的文件（路径+改动类型）
   - 文件命名遵循现有约定
   - 参考 `quick-context.md` 中的目录/命名约束，避免偏离既有架构

2. **组件设计**：
   - 主要类/函数/组件（名称+接口）
   - 复用现有组件的方式
   - 新增抽象（如需要）

3. **数据流设计**：
   - 输入输出定义
   - 关键数据结构
   - 与现有系统的集成点

4. **风险点识别**：
   - 可能的技术挑战
   - 依赖风险
   - 性能瓶颈

5. **技术决策**：
   - 选用的技术栈/库/工具
   - 设计模式与架构选择
   - 性能与安全考虑

6. **实施顺序**：
   - 按依赖关系排序的实施步骤
   - 每个步骤附带需要满足的验收标准或相关PRD章节

7. **需求映射**：
   - 列出各验收标准对应的实现路径（文件+函数）
   - 标记关键依赖、配置或开关，方便后续验证
   - 识别可在阶段3复用的工具脚本/命令

## 输出格式：
生成技术方案摘要（保存为 ./.claude/specs/{TASK}/tech-design.md）：
- 文件清单（新建/修改）
- 核心功能定义
- 风险点（如有）
- 技术决策说明
- 实施步骤列表
- 验收标准 ↔ 实现映射表（如“标准1 -> src/.../handler.ts#handle”）

限制：
- 方案说明 ≤ 500字
- 实施步骤 ≤ 8步
```

#### 2.2 方案审核（交互式）

展示技术方案摘要给用户：

```
🏗️ 技术方案摘要

文件操作：
📝 新建：
- [文件1]: [职责说明]
- [文件2]: [职责说明]
- [更多文件]
✏️ 修改：
- [文件3]: [改动类型]
- [文件4]: [改动类型]
- [更多文件]

核心功能定义：
- [功能1名称]：[一句话说明]
- [功能2名称]：[一句话说明]
- [更多功能]

技术决策：
- [决策1]：[原因]
- [决策2]：[原因]
- [更多决策]

实施步骤：
1. [步骤1]: [一句话说明]
2. [步骤2]: [一句话说明]
3. [更多步骤]

风险提示：
- [风险1]: [说明]
- [风险2]: [说明]
- [更多风险]

是否批准方案并开始开发？(yes/no/modify/back/具体修改意见)
```

**等待用户确认**：
- 如果回复 `yes/是/批准/开始` → 进入阶段3
- 如果回复 `no/否/重做` → 返回阶段2重新设计
- 如果回复 `modify/修改` → 询问具体修改要求，调整方案后重新展示
- 如果回复 `back/返回` → 返回阶段1修改PRD
- 如果回复具体修改意见 → 更新技术方案，重新展示确认
- 每轮交互都要将最新摘要写入 `tech-design.md` 并同步 `progress.json` 的阶段/重试计数

**最大重试次数**：3次
如果3次设计后仍不满意，建议：
- 或由用户提供技术方案指导,更新

---

### 阶段3：功能实施（自动执行）

**目标**：按技术方案完成代码实现

```
使用开发工程师智能体[fa-developer]：
"实施功能并确保代码质量

技术方案路径：./.claude/specs/{TASK}/tech-design.md
PRD路径：./.claude/specs/{TASK}/requirements.md
仓库架构：./.claude/quick-context.md

在开始编码前，需要：
- 根据技术方案列出待实现检查表，并与验收标准逐条对齐
- 确认所需依赖/生成脚本均可执行（如 `npm test`、`make build`）
- 在 `./.claude/specs/{TASK}/implementation.log` 中记录起始时间和计划

## 实施要求：
1. **代码质量**：
   - 遵循仓库的代码风格约定
   - 添加必要的注释与文档
   - 使用类型标注（如适用）
   - 处理边界情况与错误

2. **架构一致性**：
   - 遵循现有目录结构
   - 复用现有组件与工具函数
   - 保持命名规范一致
   - 遵循现有设计模式

3. **渐进式开发**：
   - 按技术方案的步骤顺序实施
   - 每完成一个步骤报告进度
   - 遇到问题及时说明并请求指导

4. **自测要求**：
   - 手动验证核心功能
   - 确保不破坏现有功能
   - 检查边界情况

## 实施步骤：
[按技术方案的步骤执行，每完成一项立即更新 implementation.log 与进度文件]

## 进度报告格式：
每完成一个步骤后报告：
✅ 步骤X完成：[步骤描述]
   - 新建文件：[文件路径]
   - 修改文件：[文件路径]
   - 关键改动：[简要说明]
   - 下一步：[下个步骤]
   - 覆盖的验收标准：[标准编号或名称]

## 错误处理：
如果实施过程中遇到问题：
1. **技术障碍**：
   - 暂停实施，说明遇到的问题
   - 提供2-3个可选解决方案
   - 等待用户选择方案或提供指导
   - 更新技术方案（如需要），并记录在 implementation.log

2. **设计缺陷**：
   - 如果发现技术方案不可行
   - 说明具体问题并建议调整
   - 返回阶段2重新设计

3. **范围蔓延**：
   - 如果发现需求超出预期
   - 提示用户确认是否继续[yes/no],yes继续，no返回阶段1修改PRD

## 进度保存：
每完成一个步骤后，自动保存进度到：
`./.claude/specs/{TASK}/progress.json`
- 如果步骤涉及故障/回退，记录在 `implementation.log` 中并关联问题编号

包含内容：
- 当前阶段与步骤
- 已完成的文件列表
- 待完成的任务
- 遇到的问题记录
- 对应的验收标准/PRD章节

如流程中断，可使用 `/quick-feature --resume {TASK}` 恢复"
```

**实时进度展示**：
```
🚀 开发进度

✅ 步骤1：创建基础接口定义
   📝 src/types/feature.ts
✅ 步骤2：实现核心逻辑
   📝 src/services/feature-service.ts
⏳ 步骤3：集成到现有系统（进行中...）
⬜ 步骤4：添加错误处理
⬜ 步骤5：编写文档
```

---

### 阶段4：质量验证（可选 - 默认执行）

**目标**：确保代码质量与功能完整

#### 4.1 代码审查（除非 --skip-review）

```
使用代码审查智能体[fa-code-reviewer]：
"审查新实现的代码

实施文件：[从阶段3获取]
PRD路径：./.claude/specs/{TASK}/requirements.md
技术方案路径：./.claude/specs/{TASK}/tech-design.md
审查记录：./.claude/specs/{TASK}/review-report.md

## 审查要点：
1. **功能完整性**：是否满足所有验收标准
2. **代码质量**：可读性、可维护性、性能
3. **架构一致性**：是否遵循现有模式
4. **潜在问题**：边界情况、错误处理、安全性
5. **一致性校验**：代码实现与技术方案的差异是否被记录（如有偏差需在 implementation.log 标注原因）

## 输出格式：
- 审查结果：通过/有风险/不通过
- 问题清单（如有）：[问题描述 + 建议修复]
- 优化建议（可选）：[改进方向]
- 严重级别：Blocker/High/Medium/Low，需说明影响范围
- 输出需同步到 `review-report.md`，并在 `progress.json` 中登记状态

限制：
- 仅标记关键问题（不要求完美）
- 优化建议 ≤ 3条"
```

如果审查不通过，返回阶段3进行修复。

#### 4.2 测试验证（除非 --skip-tests）

```
使用测试验证智能体[fa-tester]：
"验证功能是否符合验收标准

实施文件：[从阶段3获取]
PRD路径：./.claude/specs/{TASK}/requirements.md
验收标准：[从PRD提取]
测试记录：./.claude/specs/{TASK}/test-report.md

## 验证任务：
1. **功能测试**：
   - 验证每个验收标准
   - 测试正常流程
   - 测试边界情况

2. **集成测试**：
   - 与现有功能的兼容性
   - 不影响现有功能

3. **测试报告**：
   - 验收标准检查清单
   - 发现的问题（如有）
   - 测试结论（通过/未通过）
   - 为每个问题标注严重度（Critical/Major/Minor）与复现步骤
   - 记录建议的回归范围

限制：
- 使用现有测试框架（如Jest/Vitest/Pytest等）
- 覆盖每个验收标准至少一次
- 测试报告 ≤ 200字，仍需包含上述严重度/结论字段"
```

**展示测试报告**：
```
✅ 测试报告

验收标准检查：
✓ [标准1] - 通过
✓ [标准2] - 通过
✓ [标准3] - 通过

集成测试：
✓ 不影响现有功能
✓ 与[组件X]正常集成

发现的问题：
- [问题描述]（严重度：低/中/高）

测试结论：通过 ✅
```

**如果测试未通过**：
1. 记录测试失败的具体问题
2. 分析问题严重程度：
   - **严重问题**（功能不可用）→ 必须修复
   - **中等问题**（部分场景有问题）→ 建议修复
   - **轻微问题**（边界情况）→ 记录技术债，可选修复
3. 返回阶段3进行修复
4. 修复后重新运行测试
- 同步 `test-report.md` 和 `progress.json`，并将对应的验收标准标记为未通过

**回退循环控制**：
- 最大修复次数：3次
- 如果3次修复后仍有严重问题：
  - 暂停流程，请求用户介入
  - 展示当前代码状态和问题清单
  - 由用户决定：继续修复/接受现状/放弃功能

**代码审查未通过处理**：
如果审查结果为"不通过"：
1. 列出所有关键问题
2. 返回阶段3修复问题
3. 修复后重新审查
4. 最大审查次数：2次
5. 如仍不通过，转为手动审查

---

### 阶段5：交付与文档（自动执行）

**目标**：完成功能交付并生成必要文档

#### 5.1 生成文档

**标准文档**（默认）：
```
生成以下文档：
1. 功能说明：./.claude/specs/{TASK}/README.md
   - 功能描述
   - 使用方法
   - API文档（如适用）
   - 配置说明（如适用）
   - 链接到相关验收标准或使用示例

2. 变更记录：./.claude/specs/{TASK}/CHANGELOG.md
   - 新增文件列表
   - 修改文件列表
   - 关键改动说明
   - 对应 commit/PR 信息（如有）

3. 代码内文档：
   - 关键函数的JSDoc/注释
   - 接口/类型的说明
   - 在注释中引用实现所覆盖的验收标准编号
```

**最简文档**（`--minimal-docs`）：
```
仅生成：
1. 快速说明：./.claude/specs/{TASK}/QUICKSTART.md
   - 功能一句话描述
   - 使用示例（1-2个）
   - 新增的关键文件路径
```

#### 5.3 交付摘要

生成完成报告：

```
🎉 功能实施完成

📋 功能名称：[功能名]
⏱️ 总耗时：[预估时间]
📊 复杂度：[简单/中等/复杂]

📁 文件变更：
新建：
  - [文件1]（[行数] 行）
  - [文件2]（[行数] 行）
修改：
  - [文件3]（[改动行数] 行）

✅ 验收标准：全部通过 (X/X)

📚 文档位置：
  - 功能说明：./.claude/specs/{TASK}/README.md
  - 技术方案：./.claude/specs/{TASK}/tech-design.md
  - 变更记录：./.claude/specs/{TASK}/CHANGELOG.md
  - 审查记录：./.claude/specs/{TASK}/review-report.md
  - 测试记录：./.claude/specs/{TASK}/test-report.md

🚀 后续建议：
- [建议1]
- [建议2]

- 确认 `progress.json` 已标记为 Stage 5 / completed
```


## 输出目录结构

```
./.claude/
├── quick-context.md                      # 仓库架构快速参考
└── specs/
    └── {TASK}/
        ├── requirements.md               # 需求摘要
        ├── tech-design.md                # 技术方案
        ├── progress.json                 # 进度状态（用于恢复）
        ├── implementation.log            # 实施日志
        ├── README.md                     # 功能说明（标准文档）
        ├── QUICKSTART.md                 # 快速说明（--minimal-docs）
        └── CHANGELOG.md                  # 变更记录
```

---

## 文档格式模板

### quick-context.md 格式

```markdown
# 项目架构快速参考

生成时间：{timestamp}
扫描范围：{scope}

## 项目类型
- 类型：{前端/后端/全栈/库/工具}
- 应用类型：{Web应用/API服务/桌面应用/CLI工具}

## 技术栈
- 主要语言：{语言} ({版本})
- 核心框架：{框架名称} ({版本})
- 包管理器：{npm/yarn/pnpm/pip/等}
- 构建工具：{webpack/vite/等}

## 目录结构
```
{关键目录树}
```

## 代码组织
- 命名规范：{kebab-case/camelCase/PascalCase}
- 模块模式：{ESM/CommonJS/等}
- 分层结构：{MVC/分层架构/等}

## 可复用组件
1. {组件名称}：{路径} - {说明}
2. {组件名称}：{路径} - {说明}
3. ...

## 代码风格
- 配置文件：{.eslintrc/.prettierrc/等}
- 缩进：{空格数}个空格
- 引号：{单引号/双引号}
- 其他约定：{列举}

## 测试
- 测试框架：{Jest/Vitest/Pytest/等}
- 测试位置：{__tests__/test/等}
- 覆盖率要求：{如有}

## 建议实施位置
基于功能类型的建议目录：
- UI组件：{路径}
- API接口：{路径}
- 业务逻辑：{路径}
- 工具函数：{路径}
```

### requirements.md 格式

```markdown
# 功能需求：{功能名称}

生成时间：{timestamp}
清晰度评分：{分数}/10
复杂度：{简单/中等/复杂}

## 核心功能
{一句话描述主要功能}

## 用户故事
1. 作为{角色}，我想{功能}，以便{目标}
2. 作为{角色}，我想{功能}，以便{目标}
3. ...

## 验收标准
- [ ] {标准1}
- [ ] {标准2}
- [ ] {标准3}
- [ ] ...

## 技术约束
- {约束1}
- {约束2}
- ...

## 影响范围
- 预计新建文件：{数量}个
- 预计修改文件：{数量}个
- 涉及模块：{模块列表}

## 非功能需求
- 性能要求：{如有}
- 安全要求：{如有}
- 兼容性：{如有}
```

### tech-design.md 格式

```markdown
# 技术方案：{功能名称}

生成时间：{timestamp}
基于PRD：requirements.md

## 文件规划

### 新建文件
1. `{文件路径}`
   - 职责：{职责说明}
   - 类型：{组件/服务/工具/等}

2. `{文件路径}`
   - 职责：{职责说明}
   - 类型：{组件/服务/工具/等}

### 修改文件
1. `{文件路径}`
   - 改动类型：{新增/修改/删除}
   - 改动说明：{说明}

## 核心接口定义

### {接口/类/函数名称1}
```{语言}
{接口定义代码}
```
说明：{一句话说明}

### {接口/类/函数名称2}
```{语言}
{接口定义代码}
```
说明：{一句话说明}

## 数据流设计

### 输入
- {输入1}：{类型} - {说明}
- {输入2}：{类型} - {说明}

### 输出
- {输出1}：{类型} - {说明}
- {输出2}：{类型} - {说明}

### 数据结构
```{语言}
{关键数据结构定义}
```

## 集成点
- 与{现有模块1}集成：{集成方式}
- 与{现有模块2}集成：{集成方式}

## 实施步骤

1. **{步骤1名称}**
   - 任务：{具体任务}
   - 产出：{文件或代码}

2. **{步骤2名称}**
   - 任务：{具体任务}
   - 产出：{文件或代码}

3. ...

## 风险点
- {风险1}：{说明及应对措施}
- {风险2}：{说明及应对措施}

## 技术决策
- {决策1}：{原因}
- {决策2}：{原因}
```

### progress.json 格式

```json
{
  "featureName": "{功能名称}",
  "startTime": "{ISO时间戳}",
  "lastUpdateTime": "{ISO时间戳}",
  "currentStage": "{阶段编号：0-5}",
  "currentStep": "{当前步骤编号}",
  "status": "{状态：in-progress/blocked/completed}",
  "completedSteps": [
    {
      "stage": 0,
      "step": 1,
      "description": "{步骤描述}",
      "completedAt": "{ISO时间戳}"
    }
  ],
  "filesCreated": [
    {
      "path": "{文件路径}",
      "lines": {行数},
      "createdAt": "{ISO时间戳}"
    }
  ],
  "filesModified": [
    {
      "path": "{文件路径}",
      "linesChanged": {行数},
      "modifiedAt": "{ISO时间戳}"
    }
  ],
  "issues": [
    {
      "type": "{类型：error/warning/info}",
      "description": "{问题描述}",
      "stage": {阶段编号},
      "resolved": {true/false},
      "timestamp": "{ISO时间戳}"
    }
  ],
  "retryCount": {
    "stage1": 0,
    "stage2": 0,
    "stage3": 0,
    "stage4": 0
  },
  "userInputs": [
    {
      "prompt": "{提示内容}",
      "response": "{用户回复}",
      "timestamp": "{ISO时间戳}"
    }
  ]
}
```

---

## 成功标准

- ✅ 仓库架构识别准确（主要语言、框架、目录结构）
- ✅ 需求明确（清晰度 ≥ 7分）
- ✅ 技术方案可行（用户批准）
- ✅ 代码实施完成（所有验收标准满足）
- ✅ 质量验证通过（如未跳过）
- ✅ 文档生成完整（根据选项）

---
