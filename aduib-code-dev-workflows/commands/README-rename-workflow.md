# 重命名错误修复工作流

## 概述

这是一个专门处理命名遗漏和重命名错误的多智能体协同工作流。通过4个专业智能体的配合，自动完成代码库中的全面重命名，确保零遗漏、零错误。

## 快速开始

### 最简单的使用方式

```bash
/quick-rename oldName newName
```

### 或基于错误信息

```bash
/rename-fixer "ReferenceError: oldName is not defined"
```

## 智能体架构

```
┌─────────────────────────────────────────────────────────┐
│                重命名修复协调者                           │
│           (Rename Fix Orchestrator)                     │
└───────────────────┬─────────────────────────────────────┘
                    │
        ┌───────────┼───────────┐
        │           │           │
        ▼           ▼           ▼
┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐
│ 命名侦察员 │→│ 影响分析师 │→│ 批量修复员 │→│ 验证专家  │
│ Detective │  │ Analyzer │  │  Fixer  │  │Validator │
└──────────┘  └──────────┘  └──────────┘  └──────────┘
     │             │             │             │
     ▼             ▼             ▼             ▼
  引用清单     影响分析      变更执行      质量验证
              风险评估      批量修复      得分评估
              修复策略      追踪记录      迭代反馈
```

## 工作流程

### 阶段1️⃣：侦察与发现
**智能体**：rename-detective  
**职责**：全局扫描，发现所有命名引用

- 扫描所有源代码文件
- 检查配置文件（JSON、YAML、XML等）
- 分析文档和注释
- 识别字符串字面量和动态引用

**输出**：
- 完整引用清单（文件路径+行号）
- 引用类型分类（导入/配置/文档等）
- 引用热力图（高频使用区域）

### 阶段2️⃣：影响分析
**智能体**：impact-analyzer  
**职责**：评估重命名影响和制定策略

- 分析模块间依赖关系
- 评估风险等级（高/中/低）
- 识别破坏性变更
- 制定分批次修复计划

**输出**：
- 影响范围报告
- 风险评级和优先级
- 修复策略（4个批次）
- 时间和资源估算

### 阶段3️⃣：批量修复
**智能体**：batch-fixer  
**职责**：执行系统化的批量重命名

**分批次执行**：
- **P0批次**：编译修复（导入、类型、导出）
- **P1批次**：运行时修复（配置、API路径）
- **P2批次**：内部修复（函数调用、属性访问）
- **P3批次**：文档修复（文档、注释）

**输出**：
- 所有文件的修复更改
- 变更摘要报告
- 人工确认项清单
- 回滚脚本

### 阶段4️⃣：验证与确认
**智能体**：rename-validator  
**职责**：验证修复完整性和正确性

**多维度验证**：
- 残留扫描（多模式搜索旧名称）
- 编译检查（语法、类型、导入）
- 测试执行（单元测试、集成测试）
- 导入完整性（循环依赖检测）

**评分标准**：
- 得分 ≥95%：✅ 通过，工作流完成
- 得分 85-94%：⚠️ 有条件通过，需处理关键项
- 得分 <85%：❌ 需要二次修复

**输出**：
- 验证报告（含完成度得分）
- 遗漏项清单（如有）
- 质量门控判定
- 改进建议

### 迭代机制🔄

如果验证得分 <95%，自动触发二次修复：
1. 验证专家识别遗漏的引用
2. 提供详细的修复指导
3. 批量修复员针对遗漏项修复
4. 验证专家再次验证
5. 重复直到达到95%阈值（最多3轮）

## 命令对比

### `/rename-fixer` - 完整版

**适用场景**：
- 复杂的重命名操作
- 需要详细的分析报告
- 涉及多种文件类型
- 可能有外部依赖影响

**特点**：
- 支持灵活的输入（错误信息、描述等）
- 生成详细的分析和报告
- 可分步执行和查看
- 提供完整的回滚支持

**示例**：
```bash
/rename-fixer "将函数 calculatePrice 重命名为 computeTotalCost，修复所有引用"
/rename-fixer "ReferenceError: getUserData is not defined (原名：getUserData)"
```

### `/quick-rename` - 快速版

**适用场景**：
- 简单的名称替换
- 内部代码重命名
- 快速修复场景

**特点**：
- 简单的命令行参数
- 全自动执行
- 标准格式报告
- 快速完成

**示例**：
```bash
/quick-rename oldName newName
/quick-rename getUserData fetchUserInfo
```

## 智能特性

### 🎯 智能引用检测

- **多模式匹配**：精确匹配、大小写变体、命名约定变体
- **上下文感知**：区分同名不同作用域的引用
- **动态引用识别**：字符串拼接、反射调用等特殊情况
- **跨文件类型**：代码、配置、文档统一处理

### 🛡️ 安全修复策略

- **非侵入式修复**：最小化代码结构变动
- **增量验证**：每批次修复后即时验证
- **原子操作**：支持整体回滚
- **格式保持**：保留原有代码风格和注释

### 🔍 多维度验证

- **完整性检查**：多模式残留扫描
- **正确性检查**：编译、类型、测试
- **质量评分**：量化的完成度指标（0-100%）
- **自动迭代**：不达标自动触发修复

### 📊 详细报告

生成在 `.claude/rename-fixes/{timestamp}-{old}-to-{new}/`：

| 文件 | 说明 |
|-----|------|
| `reference-map.json` | 完整的引用清单（文件、行号、类型） |
| `reference-heatmap.md` | 引用热力图和高频文件统计 |
| `impact-analysis.md` | 影响范围、风险评级、修复策略 |
| `changes-summary.md` | 变更摘要、统计数据、修复详情 |
| `validation-report.md` | 验证结果、得分、遗漏项、建议 |
| `manual-review-items.md` | 需要人工确认的项目清单 |
| `rollback-script.sh` | 回滚脚本（如需要） |

## 质量保证

### ✅ 质量门控

| 得分范围 | 判定 | 说明 |
|---------|------|------|
| ≥95% | ✅ 通过 | 生产就绪，可直接部署 |
| 85-94% | ⚠️ 有条件通过 | 需处理关键问题后部署 |
| <85% | ❌ 不通过 | 需要二次修复 |

### 📋 验证清单

- [ ] ✅ 残留扫描：无遗漏的旧名称引用
- [ ] ✅ 编译检查：无语法或类型错误
- [ ] ✅ 导入验证：所有导入正确解析
- [ ] ✅ 测试执行：单元测试全部通过
- [ ] ✅ 功能验证：关键路径测试通过
- [ ] ⚠️ 人工确认：标记需要人工审查的项

### 🔄 迭代保证

- 最多3轮修复迭代
- 每轮都有详细的反馈
- 累积上下文确保进步
- 避免无限循环

## 使用示例

### 示例1：简单函数重命名
```bash
/quick-rename calculateTotal computeSum
```
**预期**：5-10分钟完成，全自动

### 示例2：类重命名（包含配置）
```bash
/rename-fixer "类 UserManager 改为 UserService"
```
**预期**：15-25分钟，可能需要人工确认配置项

### 示例3：基于错误信息
```bash
/rename-fixer "TypeError: oldHelper is not a function. 原名：oldHelper，新名：newHelper"
```
**预期**：10-15分钟，针对性修复

### 示例4：跨文件类型
```bash
/quick-rename service_name serviceName
```
**预期**：处理代码、配置、文档中的所有引用

## 最佳实践

### ✅ 推荐做法

1. **在功能分支执行**
   ```bash
   git checkout -b fix/rename-operation
   /quick-rename oldName newName
   ```

2. **查看生成的报告**
   ```bash
   cat .claude/rename-fixes/latest/changes-summary.md
   ```

3. **处理人工确认项**
   - 查看 `manual-review-items.md`
   - 优先处理高优先级项
   - 考虑向后兼容性

4. **执行完整测试**
   ```bash
   npm run test
   npm run test:integration
   npm run lint
   ```

5. **代码审查**
   - 审查关键文件的变更
   - 确认配置修改的正确性
   - 检查文档的一致性

### ❌ 避免的做法

1. ❌ 不要在主分支直接执行
2. ❌ 不要忽略人工确认项
3. ❌ 不要跳过测试阶段
4. ❌ 不要在没有备份的情况下执行
5. ❌ 不要用于跨仓库重命名

## 故障排除

### 问题：验证得分低
**现象**：得分 <95%  
**原因**：存在遗漏引用或编译错误  
**解决**：查看验证报告，工作流会自动二次修复

### 问题：动态引用无法处理
**现象**：标记为需人工确认  
**原因**：动态属性访问、字符串拼接等  
**解决**：手动审查运行时行为，添加映射逻辑

### 问题：测试失败
**现象**：测试未通过  
**原因**：测试中的硬编码值或mock未更新  
**解决**：检查测试文件中的字符串字面量和mock

### 问题：配置文件未更新
**现象**：配置引用未修复  
**原因**：深层嵌套或特殊格式  
**解决**：检查 `manual-review-items.md`，手动处理

## 文件结构

```
当前/
├── commands/chaorenex1/
│   ├── rename-fixer.md          # 完整版命令
│   ├── quick-rename.md          # 快速版命令
│   └── rename-examples.md       # 使用示例
│
├── agents/chaorenex1/
│   ├── rename-detective.md      # 智能体1：侦察员
│   ├── impact-analyzer.md       # 智能体2：分析师
│   ├── batch-fixer.md           # 智能体3：修复员
│   └── rename-validator.md      # 智能体4：验证专家
│
└── .claude/rename-fixes/        # 输出目录（自动创建）
    └── {timestamp}-{old}-to-{new}/
        ├── reference-map.json
        ├── impact-analysis.md
        ├── changes-summary.md
        ├── validation-report.md
        └── manual-review-items.md
```

## 技术特点

### 1. 多智能体协同
- 4个专业智能体分工明确
- 流水线式处理，高效协同
- 每个阶段独立验证

### 2. 增量验证
- 批量修复后即时验证
- 失败立即回滚
- 避免积累错误

### 3. 智能迭代
- 自动识别遗漏项
- 针对性二次修复
- 最多3轮确保质量

### 4. 全面追踪
- 完整的变更记录
- 详细的分析报告
- 可追溯的决策依据

### 5. 安全机制
- 自动备份
- 支持回滚
- 非破坏性修改

## 性能指标

| 指标 | 目标值 | 说明 |
|-----|--------|------|
| 召回率 | ≥98% | 发现所有真实引用 |
| 精确率 | ≥95% | 避免误报 |
| 自动修复率 | ≥90% | 自动完成的修复比例 |
| 验证得分 | ≥95% | 质量门控阈值 |
| 处理速度 | ~50引用/分钟 | 平均修复速度 |

## 适用场景

### ✅ 适用
- 函数/变量重命名
- 类/接口重命名
- 模块重命名
- 配置键重命名
- 命名规范统一

### ⚠️ 需谨慎
- 公共API重命名（考虑向后兼容）
- 数据库schema变更（需单独迁移）
- 外部依赖的名称（可能影响集成）

### ❌ 不适用
- 跨仓库重命名
- 需要复杂语义理解的重构
- 涉及第三方库内部的名称

## 扩展性

### 自定义智能体
可以扩展新的智能体处理特定场景：
- 数据库迁移生成器
- API版本管理器
- 向后兼容层生成器

### 自定义规则
可以配置特定的处理规则：
- 命名约定转换
- 特定文件类型的处理
- 自定义验证标准

### 集成能力
可以与其他工具集成：
- Git工作流
- CI/CD流程
- 代码审查工具

## 总结

重命名错误修复工作流通过4个专业智能体的协同工作，提供了一个：

- 🚀 **高效**：自动化完成繁琐的重命名工作
- 🎯 **准确**：多维度验证确保零遗漏
- 🛡️ **安全**：增量验证和回滚机制
- 📊 **透明**：详细的报告和追踪
- 🔄 **智能**：自动迭代优化

一条命令，解决所有重命名引发的错误！

## 快速链接

- [完整命令文档](./rename-fixer.md)
- [快速命令文档](./quick-rename.md)
- [使用示例](./rename-examples.md)
- [侦察员智能体](../agents/chaorenex1/rename-detective.md)
- [分析师智能体](../agents/chaorenex1/impact-analyzer.md)
- [修复员智能体](../agents/chaorenex1/batch-fixer.md)
- [验证专家智能体](../agents/chaorenex1/rename-validator.md)
